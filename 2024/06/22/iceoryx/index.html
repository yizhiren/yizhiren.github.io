<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yizhi.ren","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="SOA框架iceoryx原理解析简介这篇文章，会介绍一个SOA框架，框架提供高效的通信能力。这个是他的logo，很漂亮，会让你忍不住想，这大概是个很酷的框架。  在我之前的一篇微服务的文章中曾经总结了微服务跟SOA的差异点和相同点，总结的结论如下： 1234差异可以归纳为：SOA面向企业范围，微服务面向应用范围。SOA带有异构集成的语义，微服务没有这个语义。SOA服务内部支持组件分离的架构，微服务">
<meta property="og:type" content="article">
<meta property="og:title" content="SOA框架iceoryx原理解析">
<meta property="og:url" content="https://yizhi.ren/2024/06/22/iceoryx/index.html">
<meta property="og:site_name" content="一支人">
<meta property="og:description" content="SOA框架iceoryx原理解析简介这篇文章，会介绍一个SOA框架，框架提供高效的通信能力。这个是他的logo，很漂亮，会让你忍不住想，这大概是个很酷的框架。  在我之前的一篇微服务的文章中曾经总结了微服务跟SOA的差异点和相同点，总结的结论如下： 1234差异可以归纳为：SOA面向企业范围，微服务面向应用范围。SOA带有异构集成的语义，微服务没有这个语义。SOA服务内部支持组件分离的架构，微服务">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yizhi.ren/linkimage/iceoryx/iceoryx_logo.jpg">
<meta property="og:image" content="https://yizhi.ren/linkimage/iceoryx/iceoryx_process.jpg">
<meta property="og:image" content="https://yizhi.ren/linkimage/iceoryx/roudi_publish_create_flow.png">
<meta property="og:image" content="https://yizhi.ren/linkimage/iceoryx/condition_variable_data_flow.png">
<meta property="og:image" content="https://yizhi.ren/linkimage/iceoryx/memory_manager_bylevel.png">
<meta property="og:image" content="https://yizhi.ren/linkimage/iceoryx/iceoryx_memory_allocate.png">
<meta property="article:published_time" content="2024-06-22T09:10:46.000Z">
<meta property="article:modified_time" content="2024-06-22T09:10:46.000Z">
<meta property="article:author" content="yizhiren">
<meta property="article:tag" content="通信">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yizhi.ren/linkimage/iceoryx/iceoryx_logo.jpg">


<link rel="canonical" href="https://yizhi.ren/2024/06/22/iceoryx/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yizhi.ren/2024/06/22/iceoryx/","path":"2024/06/22/iceoryx/","title":"SOA框架iceoryx原理解析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SOA框架iceoryx原理解析 | 一支人</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-69495409-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-69495409-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?3aa0f62e48c3501c66bc10dbe7a49356"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">一支人</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">碎碎念</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#SOA%E6%A1%86%E6%9E%B6iceoryx%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">SOA框架iceoryx原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.2.1.</span> <span class="nav-text">标准化服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1"><span class="nav-number">1.2.2.</span> <span class="nav-text">同主机通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">进程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">进程模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92"><span class="nav-number">2.</span> <span class="nav-text">交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#REG-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">REG 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CREATE-PUBLISHER-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.2.</span> <span class="nav-text">CREATE_PUBLISHER 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CREATE-SUBSCRIBER-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.3.</span> <span class="nav-text">CREATE_SUBSCRIBER 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CREATE-CONDITION-VARIABLE-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.4.</span> <span class="nav-text">CREATE_CONDITION_VARIABLE 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TERMINATION-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.5.</span> <span class="nav-text">TERMINATION 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KEEPALIVE-%E5%91%BD%E4%BB%A4"><span class="nav-number">2.6.</span> <span class="nav-text">KEEPALIVE 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="nav-number">2.7.</span> <span class="nav-text">其他命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RouDi"><span class="nav-number">3.</span> <span class="nav-text">RouDi</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E5%85%A5%E5%8F%A3"><span class="nav-number">3.1.</span> <span class="nav-text">功能入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98"><span class="nav-number">3.2.</span> <span class="nav-text">创建内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB"><span class="nav-number">3.2.1.</span> <span class="nav-text">对象关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">3.2.2.</span> <span class="nav-text">内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%80%BC%E5%A1%AB%E5%85%85"><span class="nav-number">3.2.3.</span> <span class="nav-text">内存初始值填充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-number">3.3.</span> <span class="nav-text">创建内存池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pool%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.1.</span> <span class="nav-text">pool管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pool%E5%88%9B%E5%BB%BA"><span class="nav-number">3.3.2.</span> <span class="nav-text">pool创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%9B%BE"><span class="nav-number">3.4.</span> <span class="nav-text">完整的内存分配图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime"><span class="nav-number">4.</span> <span class="nav-text">Runtime</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-initRuntime"><span class="nav-number">4.1.</span> <span class="nav-text">初始化 initRuntime</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-PoshRuntimeImpl"><span class="nav-number">4.1.1.</span> <span class="nav-text">实例化 PoshRuntimeImpl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PoshRuntimeImpl%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.2.</span> <span class="nav-text">PoshRuntimeImpl构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%9F%E5%86%85%E5%AD%98-loan"><span class="nav-number">4.2.</span> <span class="nav-text">借内存 loan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E6%95%B0%E6%8D%AE-publish"><span class="nav-number">4.3.</span> <span class="nav-text">发数据 publish</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="nav-number">5.</span> <span class="nav-text">下一步</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yizhiren"
      src="https://avatars0.githubusercontent.com/u/15405596">
  <p class="site-author-name" itemprop="name">yizhiren</p>
  <div class="site-description" itemprop="description">[&](){}</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yizhi.ren/2024/06/22/iceoryx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/15405596">
      <meta itemprop="name" content="yizhiren">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一支人">
      <meta itemprop="description" content="[&](){}">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="SOA框架iceoryx原理解析 | 一支人">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SOA框架iceoryx原理解析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-22 17:10:46" itemprop="dateCreated datePublished" datetime="2024-06-22T17:10:46+08:00">2024-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="SOA框架iceoryx原理解析"><a href="#SOA框架iceoryx原理解析" class="headerlink" title="SOA框架iceoryx原理解析"></a>SOA框架iceoryx原理解析</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这篇文章，会介绍一个SOA框架，框架提供高效的通信能力。这个是他的logo，很漂亮，会让你忍不住想，这大概是个很酷的框架。</p>
<p><img src="/linkimage/iceoryx/iceoryx_logo.jpg" alt="iceoryx logo"></p>
<p>在我之前的一篇<a href="https://yizhi.ren/2019/06/25/microservice/">微服务</a>的文章中曾经总结了微服务跟SOA的差异点和相同点，总结的结论如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">差异可以归纳为：</span><br><span class="line">SOA面向企业范围，微服务面向应用范围。</span><br><span class="line">SOA带有异构集成的语义，微服务没有这个语义。</span><br><span class="line">SOA服务内部支持组件分离的架构，微服务则是更彻底的组件分离架构-组件在网络上隔离。</span><br></pre></td></tr></table></figure>

<p>基于这个总结，如果我们现在要写一套SOA服务框架，我们可以推导出这个框架的哪些特性呢？</p>
<blockquote>
<p>从第一条中我们可以看出这套框架将是一个企业级别的框架，他不像微服务那样可以给每个服务灵活和独立的特性，SOA框架一旦推广使用，他就是企业级别的。</p>
</blockquote>
<blockquote>
<p>从第二条中我们可以看出，这个框架承担着异构集成的职责，异构集成简单讲就是适配加标准化公开这两点。展开来讲的话就是适配现有系统中的的专用数据格式、协议、传输机制，并使用标准化的机制将这些公开为服务。</p>
</blockquote>
<blockquote>
<p>从第三点上我们可以看出，这个框架所公开的服务，他们不一定像微服务那样一个服务与一个服务之间是网络隔离的，他们有可能是位于同一个主机上的，换句话说SOA的服务与服务之间可以网络隔离也可以网络不隔理。</p>
</blockquote>
<p>这里面第一点可以认为是第二点的一个顺其自然的结果，由于各个服务都采用标准化的方式公开，那采用同一套框架是顺理成章的。所以下面我就只关注第二点和第三点。</p>
<p>这次要对其分析的这个框架叫iceoryx中文叫冰羚（其实就是对ice-oryx的翻译）。他是一个在特定领域（至少在智驾领域）很有名的SOA通信框架，在SOA特性的第二点和第三点特性中他都有很典型的体现，如下：</p>
<span id="more"></span>

<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="标准化服务"><a href="#标准化服务" class="headerlink" title="标准化服务"></a>标准化服务</h4><p>为了做到第二点标准化的服务公开，iceoryx首先要求每个服务提供服务描述信息，用来唯一标志服务网络中的一个服务；<br>其次规定了专用数据格式，必须使用用户预定义的结构体（注意iceoryx没有规定使用IDL，IDL是在DDS等别的框架中的要求），或者无结构（也就是二进制流），用户想要传递自己已有的结构，需要在收发前后做数据结构的转换和赋值，这点在各类通信框架中到并不特殊;<br>再次，在传输机制上，iceoryx封装了较为复杂的消息编排和消息路由机制，确保消息是按照各异构服务提供方和消费方的要求做了保持或者丢弃，以及按需路由到了各个异构服务。要知道微服务是不做消息编排和路由的，这个也是SOA框架复杂麻烦的地方。即便只有一个服务需要这个特性，作为公司级的框架，你就不得不提供这个特性。</p>
<h4 id="同主机通信"><a href="#同主机通信" class="headerlink" title="同主机通信"></a>同主机通信</h4><p>为了做到第三点对同一主机上的不同服务进行通信，iceoryx直接把自己瞄准在了这个细分领域，专注于提供同一主机上的不同服务之间的通信，他没有提供对不同主机上的服务的通信能力，因此在实践上，往往是跟其他框架整合使用。由于限定在同一主机上，他可以提供远高于主机之间的通信吞吐和远低于主机之间的通信延迟。</p>
<h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>我们已经知道iceoryx具有提供标准化服务的能力以及高性能同主机通信的能力，接下来我们首先来整体上大概的了解下iceoryx是如何工作的，先来看iceoryx的进程模型。</p>
<h4 id="进程模型-1"><a href="#进程模型-1" class="headerlink" title="进程模型"></a>进程模型</h4><p>接下来首先来看一下iceoryx运行时候的进程模型：<br><img src="/linkimage/iceoryx/iceoryx_process.jpg" alt="iceoryx process"><br>整个进程模型，包括3类角色，一个角色是RouDi，是一个中心进程节点，类似于Daemon进程，本身不属于业务进程，只是提供服务支持。RouDi的意思就是Route &amp; Discovery，路由和发现，用来做消息路由和服务发现。<br>一个角色是Runtime，Runtime被集成到各个业务进程中，给进程提供服务集成的能力，根据使用方式不同，有的进程变成publisher，有的变成subscriber，有的既是publisher又是subscriber。<br>第三个角色是share memory，本身被RouDi创建和销毁，但被publisher和subscriber同时使用，被用来作为高效的数据传递介质。是其高性能的关键所在。</p>
<p>RouDi和Runtime之间通过domain socket（运行在Linux系统的话）通信，RouDi作为server，Runtime作为client。</p>
<p>接下来我们分别展开来看一下内部的交互以及RouDi和Runtime内部原理。</p>
<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p>roudi与runtime的交互过程，首先是roudi要先启动，如果runtime先启动，会等待若干秒，等待roudi启动，等不到就退出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2024-06-29 16:32:03.011 [Warning]: RouDi not found - waiting ...</span><br><span class="line">2024-06-29 16:33:03.099 [ Fatal ]: Timeout registering at RouDi. Is RouDi running?</span><br></pre></td></tr></table></figure>

<p>所以所有的交互过程都是基于roudi已经启动成功的情况，暂不考虑roudi晚启动的异常情况。</p>
<p>交互总共包括以下几个指令，<code>REG</code>、<code>CREATE_PUBLISHER</code>、<code>CREATE_SUBSCRIBER</code>、<code>CREATE_CLIENT</code>，<code>CREATE_SERVER</code>、<code>CREATE_CONDITION_VARIABLE</code>、<code>CREATE_INTERFACE</code>、<code>PREPARE_APP_TERMINATION</code>、<code>TERMINATION</code>，如下面的代码所示， roudi收到对应的命令后会进入对应的命令处理逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RouDi::processMessage</span><span class="params">(<span class="keyword">const</span> runtime::IpcMessage&amp; message,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> iox::runtime::IpcMessageType&amp; cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> RuntimeName_t&amp; runtimeName)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理不同的命令</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> runtime::IpcMessageType::REG:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> runtime::IpcMessageType::CREATE_PUBLISHER:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> runtime::IpcMessageType::CREATE_SUBSCRIBER:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> runtime::IpcMessageType::CREATE_CLIENT:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> runtime::IpcMessageType::CREATE_SERVER:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> runtime::IpcMessageType::CREATE_CONDITION_VARIABLE:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> runtime::IpcMessageType::CREATE_INTERFACE:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> runtime::IpcMessageType::PREPARE_APP_TERMINATION:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> runtime::IpcMessageType::TERMINATION:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="REG-命令"><a href="#REG-命令" class="headerlink" title="REG 命令"></a>REG 命令</h3><p><code>REG</code>命令是用来告诉roudi我runtime启动了，我的名字叫xx，我的其他信息是xxx，请记录。如果原先存在同名的runtime会在此时信息被更新。每个runtime因此必须有独一无二的name。</p>
<h3 id="CREATE-PUBLISHER-命令"><a href="#CREATE-PUBLISHER-命令" class="headerlink" title="CREATE_PUBLISHER 命令"></a>CREATE_PUBLISHER 命令</h3><p><code>CREATE_PUBLISHER</code>命令是告诉roudi，我要在xx这个runtime下创建一个publisher。roudi于是分配一片内存给这个publisher，这片内存是在专为publisher们准备的相同大小内存块的内存池中选取的一个，随后把这个内存的地址回复给runtime，这个地址本质上是一个offset值，不是一个真正的内存地址，因为roudi和runtime在不同进程，大家各自有各自的内存虚地址，我给你一个虚地址过去没有什么意义。在回复地址给到runtime之前，roudi还会同时做一个服务发现的工作，他会遍历当前已经存在的subscribers，把其中topic跟你这个publisher相同的subscriber选出来，这些subscriber，每一个也都绑定了一段专属的内存块，这些选出来的subscriber对应的内存块地址会被填入到publisher的专属内存地址中，一个存放subscriber信息的队列中。这样就完成了一个初始的服务发现的工作，publisher能够成功拿到当前有哪些关注我这个topic的subscribers。runtime拿到roudi的回复，就可以做后续的消息发布工作了。下面的代码反应了这个过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">expected&lt;PublisherPortRouDiType::MemberType_t*, PortPoolError&gt;</span></span><br><span class="line"><span class="function"><span class="title">PortManager::acquirePublisherPortData</span><span class="params">(<span class="keyword">const</span> capro::ServiceDescription&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> popo::PublisherOptions&amp; publisherOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> RuntimeName_t&amp; runtimeName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      mepoo::MemoryManager* <span class="keyword">const</span> payloadDataSegmentMemoryManager,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> PortConfigInfo&amp; portConfigInfo)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acquirePublisherPortDataWithoutDiscovery</span>(</span><br><span class="line">               service, publisherOptions, runtimeName, payloadDataSegmentMemoryManager, portConfigInfo)</span><br><span class="line">        .<span class="built_in">and_then</span>([&amp;](<span class="keyword">auto</span> publisherPortData) &#123;</span><br><span class="line">            PublisherPortRouDiType <span class="built_in">port</span>(publisherPortData);</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">doDiscoveryForPublisherPort</span>(port);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的图则描述了这个过程。</p>
<p><img src="/linkimage/iceoryx/roudi_publish_create_flow.png" alt="publisher create flow"><br>(右键-在新标签页中打开图片，可以看得更清晰)</p>
<h3 id="CREATE-SUBSCRIBER-命令"><a href="#CREATE-SUBSCRIBER-命令" class="headerlink" title="CREATE_SUBSCRIBER 命令"></a>CREATE_SUBSCRIBER 命令</h3><p><code>CREATE_SUBSCRIBER</code>命令同 <code>CREATE_PUBLISHER</code>类似的，roudi先是分配一段内存给这个subscriber，然后遍历全部的publisher，把这段内存地址的信息塞到相同topic的publisher的对应结构中去，如此完成初始的服务发现机制，然后把这段内存地址响应给subscriber，后续subscriber就可以根据这个信息去读取对应的数据。上图中在subscriber1的内存区域中有一个dat数组，就是存放publisher发过来的数据的。另外熟悉共享内存数据传递的同学应该知道，数据放在指定位置后，还得去做通知唤醒，告诉对方有新数据。不过呢 <code>CREATE_SUBSCRIBER</code>这个命令不负责这件事，但又做了部分的工作。当RouDi把subscriber的内存信息塞到publisher的对应结构中时，随同一起塞入的还有一个指针，指向通知器，只不过这个时候这个指针是空指针，也就是压根不会做通知。不做通知的话subscriber怎么读消息的，答案是轮询，这个场景也是合理的，轮询在适当场景下有更佳的性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename ChunkQueueDataProperties, typename LockingPolicy&gt;</span><br><span class="line">struct ChunkQueueData : public LockingPolicy</span><br><span class="line">&#123;</span><br><span class="line">	//...</span><br><span class="line">    RelativePointer&lt;ConditionVariableData&gt; m_conditionVariableDataPtr; // 默认是空指针</span><br><span class="line">    optional&lt;uint64_t&gt; m_conditionVariableNotificationIndex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="CREATE-CONDITION-VARIABLE-命令"><a href="#CREATE-CONDITION-VARIABLE-命令" class="headerlink" title="CREATE_CONDITION_VARIABLE 命令"></a>CREATE_CONDITION_VARIABLE 命令</h3><p><code>CREATE_CONDITION_VARIABLE</code>命令的作用就是创建一个通知器，当用户代码中创建一个Listener, 他就会发送 <code>CREATE_CONDITION_VARIABLE</code>的命令，然后在用户代码中调用listener的attachEvent函数，完成subscriber与通知器的绑定，上面 <code>CREATE_SUBSCRIBER</code>命令介绍中提到的通知器指针，就会在这个时候被赋值，这样每次subscriber有新数据到来就会通知用户指定的回调。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">listener</span><br><span class="line">    .<span class="built_in">attachEvent</span>(subscriber,</span><br><span class="line">                 iox::popo::SubscriberEvent::DATA_RECEIVED,</span><br><span class="line">                 iox::popo::<span class="built_in">createNotificationCallback</span>(onSampleReceivedCallback))</span><br><span class="line">    .<span class="built_in">or_else</span>([](<span class="keyword">auto</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;unable to attach subscriberLeft&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>具体一点讲，listener对象中包含了roudi新创建的ConditionVariableData，ConditionVariableData中则包含了一个semaphore, 随后，listener会启动一个线程，线程会操作semaphore.wait()，进行等待。ConditionVariableData是被roudi创建的，pub和sub两侧都能拿到的，那么在数据传递后，pub端会随即操作semaphore.post(), 于是listener这边wait的线程就会唤醒并执行回调。ConditionVariableData在设计上支持多种事件的，因此里面有个数组，可以对应不同的事件，数组某个下标被设置上，就表示对应的事件发生，就执行对应的回调。ConditionVariableData这个类的定义可以看出这种设计。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConditionVariableData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">ConditionVariableData</span>() <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ConditionVariableData</span><span class="params">(<span class="keyword">const</span> RuntimeName_t&amp; runtimeName)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ConditionVariableData</span>(<span class="keyword">const</span> ConditionVariableData&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">ConditionVariableData</span>(ConditionVariableData&amp;&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    ConditionVariableData&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ConditionVariableData&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    ConditionVariableData&amp; <span class="keyword">operator</span>=(ConditionVariableData&amp;&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">ConditionVariableData</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    optional&lt;UnnamedSemaphore&gt; m_semaphore;</span><br><span class="line">    RuntimeName_t m_runtimeName;</span><br><span class="line">    std::<span class="keyword">atomic_bool</span> m_toBeDestroyed&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::<span class="keyword">atomic_bool</span> m_activeNotifications[MAX_NUMBER_OF_NOTIFIERS];</span><br><span class="line">    std::<span class="keyword">atomic_bool</span> m_wasNotified&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还原整个过程可以看下图：<br><img src="/linkimage/iceoryx/condition_variable_data_flow.png" alt="condition_variable_data_flow"><br>(右键-在新标签页中打开图片，可以看得更清晰)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">group CreateConditionVariableData</span><br><span class="line">Listener -&gt; Roudi: CREATE_CONDITION_VARIABLE </span><br><span class="line">Roudi -&gt; ProcessManager : addConditionVariableForProcess</span><br><span class="line">ProcessManager -&gt; PortManager : acquireConditionVariableData</span><br><span class="line">PortManager -&gt; PortPool : addConditionVariableData</span><br><span class="line">PortPool -&gt; ConditionVariableData: Create</span><br><span class="line">ConditionVariableData-&gt; PortPool : ConditionVariableDataPtr</span><br><span class="line">PortPool -&gt; PortManager : ConditionVariableDataPtr</span><br><span class="line">PortManager -&gt; ProcessManager :ConditionVariableDataPtr</span><br><span class="line">ProcessManager -&gt; Listener: ConditionVariableDataPtr</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">group SaveCallback</span><br><span class="line">Listener -&gt; Listener: AddEvent</span><br><span class="line">Listener -&gt; Event_t: Init</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">group SetConditionVariable</span><br><span class="line">Listener -&gt; Subscriber: SetConditionVariable</span><br><span class="line">Subscriber -&gt; SubscriberPortUser: SetConditionVariable</span><br><span class="line">SubscriberPortUser -&gt; ChunkReceiver : SetConditionVariable</span><br><span class="line">ChunkReceiver -&gt; ChunkQueuePopper : SetConditionVariable</span><br><span class="line">ChunkQueuePopper -&gt; ChunkQueueData : SetConditionVariableData</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">group WaitSemaphore</span><br><span class="line">Listener -&gt; ConditionListener: wait</span><br><span class="line">ConditionListener -&gt; ConditionVariableData : WaitOnSemaphore</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">group PostSemaphore</span><br><span class="line">Publisher -&gt; PublisherPortUser: sendChunk</span><br><span class="line">PublisherPortUser -&gt; ChunkSender : send</span><br><span class="line">ChunkSender -&gt; ChunkDistributor : DeliverToAllStoredQueues</span><br><span class="line">ChunkDistributor -&gt; ChunkDistributor : PushToQueue</span><br><span class="line">ChunkDistributor -&gt; ChunkQueuePusher : Push</span><br><span class="line">ChunkQueuePusher -&gt; ChunkQueueData : PushChunk</span><br><span class="line">ChunkQueuePusher -&gt; ChunkQueueData : GetConditionVariableData</span><br><span class="line">ChunkQueuePusher -&gt; ConditionNotifier : Notify</span><br><span class="line">ConditionNotifier -&gt; ConditionVariableData : PostOnSemaphore</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">group WakeupOnSemaphore</span><br><span class="line">ConditionVariableData -&gt; ConditionListener : WakeupOnSemaphore</span><br><span class="line">ConditionListener -&gt; Listener : EventId</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">group ExecuteCallback</span><br><span class="line">Listener -&gt; Listener : GetEvent</span><br><span class="line">Listener -&gt; Event_t : Callback</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">@enduml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再补一个关系图，下面这个图是来自仓库中官方的一个图(doc&#x2F;design&#x2F;listener.md)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">                                   +---------------------------+</span><br><span class="line">                                   | ConditionVariableData     |</span><br><span class="line">                                   |   - m_semaphore           |</span><br><span class="line">                                   |   - m_runtimeName         |</span><br><span class="line">                                   |   - m_toBeDestroyed       |</span><br><span class="line">                                   |   - m_activeNotifications |</span><br><span class="line">                                   +---------------------------+</span><br><span class="line">                                        | 1               | 1</span><br><span class="line">                                        |                 |</span><br><span class="line">                                        | 1               | n</span><br><span class="line">+-----------------------------------------------+ +--------------------------------------------------+</span><br><span class="line">| ConditionListener                             | | ConditionNotifier                                |</span><br><span class="line">|   ConditionListener(ConditionVariableData &amp; ) | |   ConditionNotifier(ConditionVariableData &amp;,     |</span><br><span class="line">|                                               | |                 uint64_t notificationIndex)      |</span><br><span class="line">|   bool                  wasNotified()         | |                                                  |</span><br><span class="line">|   void                  destroy()             | |   void notify()                                  |</span><br><span class="line">|   NotificationVector_t  wait()                | |                                                  |</span><br><span class="line">|   NotificationVector_t  timedWait()           | |   - m_condVarDataPtr    : ConditionVariableData* |</span><br><span class="line">|                                               | |   - m_notificationIndex                          |</span><br><span class="line">|   - m_condVarDataPtr : ConditionVariableData* | +--------------------------------------------------+</span><br><span class="line">|   - m_toBeDestroyed  : std::atomic_bool       |   </span><br><span class="line">+-----------------------------------------------+   </span><br><span class="line">        | 1              </span><br><span class="line">        |                    </span><br><span class="line">        | 1                   </span><br><span class="line">+-------------------------------------------------+   </span><br><span class="line">| Listener                                        |   </span><br><span class="line">|   attachEvent(Triggerable, EventType, Callback) |  </span><br><span class="line">|   detachEvent(Triggerable, EventType)           |  </span><br><span class="line">|                                                 |  </span><br><span class="line">|   - m_events : Event_t[]                        |  </span><br><span class="line">|   - m_thread : std::thread                      |   </span><br><span class="line">|   - m_conditionListener : ConditionListener     |  </span><br><span class="line">|                                                 |   </span><br><span class="line">| +----------------------------+                  |  </span><br><span class="line">| | Event_t                    |                  |  </span><br><span class="line">| |   void executeCallback()   |                  |  </span><br><span class="line">| |   bool reset()             |                  |  </span><br><span class="line">| |   bool init(...)           |                  |  </span><br><span class="line">| |                            |                  |           +-------------------------------------------------------+</span><br><span class="line">| |   - m_origin               |                  |           | Event_t                                               |</span><br><span class="line">| |   - m_callback             |                  |           |                                                       |</span><br><span class="line">| |   - m_invalidationCallback |                  |  1     n  |   void executeCallback()                              |</span><br><span class="line">| |   - m_eventId              |                  | --------- |   void isInitialized()                                |</span><br><span class="line">| +----------------------------+                  |           |   void init()                                         |</span><br><span class="line">+-------------------------------------------------+           |   void reset()                                        |</span><br><span class="line">                                                              |   void isEqualTo()                                    |</span><br><span class="line">                                                              |                                                       |</span><br><span class="line">                                                              |   - m_callback : GenericCallbackPtr_t                 |</span><br><span class="line">                                                              |   - m_eventType : uint64_t                            |</span><br><span class="line">                                                              +-------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>这个图中可以看出listener持有ConditionListener，listener正是通过ConditionListener实现的semaphore.wait()， 而ConditionVariableData、ConditionListener、Listener之间的关系则是1:1:1的关系。<br>另一部分ConditionNotifier是用来完成semaphore.post()操作的，因此ConditionNotifier可以构造多次执行多次,是1:n的关系。而原图中剩下的部分似乎是内容过期，已经不对了，我移除了，并 补上了Event_t部分。</p>
<h3 id="TERMINATION-命令"><a href="#TERMINATION-命令" class="headerlink" title="TERMINATION 命令"></a>TERMINATION 命令</h3><p><code>TERMINATION</code>命令发生在Runtime进程退出的时候，RouDi收到后会做一些清理操作，包括从订阅关系中移除这个进程，以及从进程列表中移除这个进程。如果Runtime进程异常退出，没来得及发送这个命令，那么这些清理操作将会发生在进程与RouDi心跳超时之后。</p>
<h3 id="KEEPALIVE-命令"><a href="#KEEPALIVE-命令" class="headerlink" title="KEEPALIVE 命令"></a>KEEPALIVE 命令</h3><p>关于心跳这个命令，在iceoryx的 <code>release_2.0</code>分支下是一条独立的命令 <code>KEEPALIVE</code>, 由runtime定时发送给RouDi，但是在master分支下，已经取消了这个命令，而是在REG命令处理的时候直接分配一段内存存放心跳信息，后面Runtime直接向这块内存更新心跳信息。</p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>此外其他的命令我在使用订阅发布机制的情况下并没有观察到，这里我不做描述，可以自行查阅代码，就在 <code>RouDi::processMessage</code>这个函数里面。</p>
<h2 id="RouDi"><a href="#RouDi" class="headerlink" title="RouDi"></a>RouDi</h2><h3 id="功能入口"><a href="#功能入口" class="headerlink" title="功能入口"></a>功能入口</h3><p>RouDi是iceoryx整体架构中的中心节点。RouDi的代码入口在 <code>iceoryx_posh\source\roudi\application\roudi_main.cpp</code>. 做的事情简单说是从配置文件加载配置，然后传入IceOryxRouDiApp类，并启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) noexcept</span><br><span class="line">&#123;</span><br><span class="line">    using iox::roudi::IceOryxRouDiApp;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    IceOryxRouDiApp roudi(config.value());</span><br><span class="line">    return roudi.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建内存"><a href="#创建内存" class="headerlink" title="创建内存"></a>创建内存</h3><p>RouDi在启动的时候做的最重要的一件事情是创建共享内存，他是怎么来创建的呢？</p>
<h4 id="对象关系"><a href="#对象关系" class="headerlink" title="对象关系"></a>对象关系</h4><p>首先来找出创建内存相关的类或对象，我根据源码上的类关系，梳理成下面的类（或者对象）关系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">IceOryxRouDiApp</span><br><span class="line">	├ IceOryxRouDiComponents</span><br><span class="line">	|	├ IceOryxRouDiMemoryManager</span><br><span class="line">	|	|	├ DefaultRouDiMemory</span><br><span class="line">	|	|	|	 ├ introspectionMemPoolBlock</span><br><span class="line">	|	|	|	 ├ discoveryMemPoolBlock</span><br><span class="line">	|	|	|	 ├ heartbeatPoolBlock</span><br><span class="line">	|	|	|	 ├ segmentManagerBlock</span><br><span class="line">	|	|	|	 └ PosixShmMemoryProvider</span><br><span class="line">	|	|	|		 └ vector&lt;MemoryBlock*&gt;</span><br><span class="line">	|	|	├ portPoolBlock</span><br><span class="line">	|	|	├ PortPool</span><br><span class="line">	|	|	└ RouDiMemoryManager</span><br><span class="line">	|	|		 └ vector&lt;MemoryProvider*&gt;</span><br><span class="line">	|	└ PortManager</span><br><span class="line">	|		├ PortPool</span><br><span class="line">	|		└ IceOryxRouDiMemoryManager</span><br><span class="line">	|</span><br><span class="line">	└ RouDi</span><br><span class="line">		├ IceOryxRouDiMemoryManager</span><br><span class="line">		└ PortManager</span><br></pre></td></tr></table></figure>

<ol>
<li>这里面两处 <code>PortManager</code>是引用同一个，两个 <code>PortPool</code>也是引用的同一个，三处 <code>IceOryxRouDiMemoryManager</code>也是引用的同一个。</li>
<li>这里面多个Block都是继承 <code>MemoryBlock</code>基类，并最终被放到 <code>vector&lt;MemoryBlock*&gt;</code>这个数组里面；</li>
<li>这里面 <code>PosixShmMemoryProvider</code>是继承 <code>MemoryProvider</code>接口的，并最终被放到 <code>vector&lt;MemoryProvider*&gt;</code>这个数组里面。</li>
</ol>
<p>这个关系中还是看不出重点，我们来看一下初始化之后这些类（或者对象）的关系变成什么样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IceOryxRouDiApp</span><br><span class="line">	├ ｛IceOryxRouDiComponents｝</span><br><span class="line">	|	├ 【IceOryxRouDiMemoryManager】</span><br><span class="line">	|	|	├ PortPool</span><br><span class="line">	|	|	|	└ PortPoolData</span><br><span class="line">	|	|	└ RouDiMemoryManager</span><br><span class="line">	|	|		 └ vector&lt;MemoryProvider*&gt;</span><br><span class="line">	|	|			└ PosixShmMemoryProvider</span><br><span class="line">	|	|				└ vector&lt;MemoryBlock*&gt;</span><br><span class="line">	|	|					├ introspectionMemPoolBlock</span><br><span class="line">	|	|					├ discoveryMemPoolBlock</span><br><span class="line">	|	|					├ heartbeatPoolBlock</span><br><span class="line">	|	|					├ segmentManagerBlock</span><br><span class="line">	|	|					└ portPoolBlock</span><br><span class="line">	|	|						└ 【PortPoolData】</span><br><span class="line">	|	└ ｛PortManager｝</span><br><span class="line">	|		├ PortPool</span><br><span class="line">	|		└ IceOryxRouDiMemoryManager</span><br><span class="line">	|</span><br><span class="line">	└ ｛RouDi｝</span><br><span class="line">		├ IceOryxRouDiMemoryManager</span><br><span class="line">		└ PortManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">｛｝和【】用来标记关键的类和对象</span><br></pre></td></tr></table></figure>

<p>可以看出，这里面 <code>IceOryxRouDiMemoryManager</code>下面挂了（引用了）一大堆的东西，有port相关的有block相关的；而反过来被多个对象引用的则是 <code>PortPoolData</code>，直接或间接地被 <code>PortManager</code>、<code>IceOryxRouDiComponents</code>、<code>RouDi</code>引用。因此这里面最核心的类就是 <code>IceOryxRouDiMemoryManager和PortPoolData</code>了。<code>IceOryxRouDiMemoryManager</code>在这里的作用是什么呢，他是负责创建 <code>PortPoolData</code>和其他的内存的。</p>
<p>这样就串起来了：<code>PortManager</code>、<code>IceOryxRouDiComponents</code>、<code>RouDi</code>引用 <code>IceOryxRouDiMemoryManager</code>和 <code>PortPoolData</code>，而 <code>IceOryxRouDiMemoryManager</code>又是创建 <code>PortPoolData</code>和其他的内存块。</p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>触发内存分配的函数调用来自 <code>IceOryxRouDiMemoryManager::createAndAnnounceMemory()</code>, 并最终调用到 <code>MemoryProvider::create()</code>, <code>PosixShmMemoryProvider</code>继承自 <code>MemoryProvider::create()</code>，因此调用的也同时是 <code>PosixShmMemoryProvider::create()</code>。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IceOryxRouDiMemoryManager::<span class="built_in">createAndAnnounceMemory</span>()</span><br><span class="line">	└&gt; RouDiMemoryManager::<span class="built_in">createAndAnnounceMemory</span>()</span><br><span class="line">		└&gt; MemoryProvider::<span class="built_in">create</span>()</span><br></pre></td></tr></table></figure>

<p><code>MemoryProvider::create</code> 内部做了两件事，一个是计算出他下面挂的 <code>vector&lt;MemoryBlock*&gt;</code>中全部block所需的内存之和，并向系统申请一整块的内存，由于我们在 <code>PosixShmMemoryProvider</code>类中，因此他申请内存的方式就是使用共享内存，在linux中就会在&#x2F;dev&#x2F;shm&#x2F;下面创建一个共享内存文件，叫iceoryx_mgmt。另一个事是从这一大片内存中切切切，切一段给这个MemoryBlock，切一段给那个MemoryBlock，切的时候都是字节对齐的，也是一段接一段连续地切的。当前，申请内存的时候已经计算上字节对齐所需要的额外的字节数的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">expected&lt;<span class="keyword">void</span>, MemoryProviderError&gt; <span class="title">MemoryProvider::create</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* memoryBlock : m_memoryBlocks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ... 累加总的内存大小</span></span><br><span class="line">        totalSize = <span class="built_in">align</span>(totalSize, alignment) + size;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ... 一次性申请总的内存</span></span><br><span class="line">    <span class="keyword">auto</span> memoryResult = <span class="built_in">createMemory</span>(totalSize, maxAlignment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 内存分配器用来切内存</span></span><br><span class="line">    <span class="function">iox::BumpAllocator <span class="title">allocator</span><span class="params">(m_memory, m_size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* memoryBlock : m_memoryBlocks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> allocationResult = allocator.<span class="built_in">allocate</span>(memoryBlock-&gt;<span class="built_in">size</span>(), memoryBlock-&gt;<span class="built_in">alignment</span>());</span><br><span class="line">        <span class="comment">// ... 切出来的一段内存分配给对应的memeoryblock</span></span><br><span class="line">        memoryBlock-&gt;m_memory = allocationResult.<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里只是申请了内存，可以认为是一段裸的内存。由于iceoryx设计上是不允许重复使用共享内存文件的，每次启动都会去清理旧的内存并新建新内存，因此这里的共享内存文件一定是新创建的，新建后被自动初始化为全零，这是共享内存默认的行为。</p>
<h4 id="内存初始值填充"><a href="#内存初始值填充" class="headerlink" title="内存初始值填充"></a>内存初始值填充</h4><p>内存在上面被创建以后，初始内存是被初始化为0，接下来就需要做内存值的填充。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IceOryxRouDiMemoryManager::<span class="built_in">createAndAnnounceMemory</span>()</span><br><span class="line">	└&gt; RouDiMemoryManager::<span class="built_in">createAndAnnounceMemory</span>()</span><br><span class="line">		├&gt; MemoryProvider::<span class="built_in">create</span>()                     <span class="comment">// 创建内存</span></span><br><span class="line">		└&gt; MemoryProvider::<span class="built_in">announceMemoryAvailable</span>()    <span class="comment">// 初始值填充</span></span><br></pre></td></tr></table></figure>

<p><code>announceMemoryAvailable</code>函数做的事情，就是依次调用他下面挂的 <code>vector&lt;MemoryBlock*&gt;</code>中每个block的 <code>onMemoryAvailable</code>函数，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemoryProvider::announceMemoryAvailable</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_memoryAvailableAnnounced)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> memoryBlock : m_memoryBlocks)</span><br><span class="line">        &#123;</span><br><span class="line">            memoryBlock-&gt;<span class="built_in">onMemoryAvailable</span>(memoryBlock-&gt;m_memory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_memoryAvailableAnnounced = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终结果是每个 <code>MemoryBlock</code>的 <code>onMemoryAvailable</code>函数被触发，每个 <code>MemoryBlock</code>负责把自己负责的那片内存进行初始化。</p>
<p>比如portPoolBlock他初始化或者说填充这片内存的方式，就是在这片地址中实例化一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void PortPoolMemoryBlock::onMemoryAvailable(not_null&lt;void*&gt; memory) noexcept</span><br><span class="line">&#123;</span><br><span class="line">    m_portPoolData = new (memory) PortPoolData&#123;m_uniqueRouDiId&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但值得展开讲的是另一个block的初始化，这个blcok是segmentManagerBlock，他是专门负责做内存池管理的，下面展开。</p>
<h3 id="创建内存池"><a href="#创建内存池" class="headerlink" title="创建内存池"></a>创建内存池</h3><p>segmentManagerBlock在初始化的时候，首先也是在这个指定的内存地址上实例化一个管理对象，但是他这个管理对象并没有占满属于这个block的全部内存，后面还有一长段空间，存放的是什么呢，是若干个无锁队列。这个无锁队列用来干什么的我们下面来讲。</p>
<h4 id="pool管理"><a href="#pool管理" class="headerlink" title="pool管理"></a>pool管理</h4><p>在<code>iceoryx_posh\etc\iceoryx\roudi_config_example.toml</code>这里存在一个RouDi的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># Adapt this config to your needs and rename it to e.g. roudi_config.toml</span><br><span class="line">[general]</span><br><span class="line">version = 1</span><br><span class="line"></span><br><span class="line">[[segment]]</span><br><span class="line"></span><br><span class="line">[[segment.mempool]]</span><br><span class="line">size = 128</span><br><span class="line">count = 10000</span><br><span class="line"></span><br><span class="line">[[segment.mempool]]</span><br><span class="line">size = 1024</span><br><span class="line">count = 5000</span><br><span class="line"></span><br><span class="line">[[segment.mempool]]</span><br><span class="line">size = 16384</span><br><span class="line">count = 1000</span><br><span class="line"></span><br><span class="line">[[segment.mempool]]</span><br><span class="line">size = 131072</span><br><span class="line">count = 200</span><br><span class="line"></span><br><span class="line">[[segment.mempool]]</span><br><span class="line">size = 524288</span><br><span class="line">count = 50</span><br><span class="line"></span><br><span class="line">[[segment.mempool]]</span><br><span class="line">size = 1048576</span><br><span class="line">count = 30</span><br><span class="line"></span><br><span class="line">[[segment.mempool]]</span><br><span class="line">size = 4194304</span><br><span class="line">count = 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个文件里面最主要的是定义了一个内存段的配置，一个内存段是多个内存池的集合，每个内存池又是固定大小的内存块的集合。其中每个[[segment]]对应一个内存段，每个[[segment.mempool]]代表内存段中的一个内存池。[[segment.mempool]]中size代表内存块大小，count达标内存块个数。</p>
<p>那么iceoryx为了管理内存池中每个内存块的使用情况，使用无锁队列来进行管理，每个[[segment.mempool]]对应一个无锁队列，这个无锁队列的队列长度就是[[segment.mempool]]中count的大小。比如上面这份配置中，iceoryx需要7个无锁队列，第一个队列的长度是10000，第二个队列的长度是5000，以此类推。</p>
<p>segmentManager在实例化一个对象后，其后面紧接着存放的就是上面的无锁队列。</p>
<h4 id="pool创建"><a href="#pool创建" class="headerlink" title="pool创建"></a>pool创建</h4><p>那么segmentManager实例化的管理对象还做了别的什么呢？</p>
<p>segmentManager最主要的是要组织好内存段和内存池的管理，这里涉及到3个层级的内存：[总内存]-&gt;[内存段]-&gt;[内存池]。反映在源码上，我们找出来下面几个关键的类，SegmentManager即可代表总内存；MePooSegment代表内存段，MemoryManager代表内存段下的内存池；MemPool代表内存池。也就是这样的层级：[SegmentManager]-&gt;[MePooSegment+MemoryManager]-&gt;[MemPool]。</p>
<p><img src="/linkimage/iceoryx/memory_manager_bylevel.png" alt="memory_manager_bylevel"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    vector&lt;SegmentType, MAX_SHM_SEGMENTS&gt; m_segmentContainer;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MePooSegment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    SharedMemoryObjectType m_sharedMemoryObject;</span><br><span class="line">    MemoryManagerType m_memoryManager;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    vector&lt;MemPool, MAX_NUMBER_OF_MEMPOOLS&gt; m_memPoolVector;</span><br><span class="line">    vector&lt;MemPool, 1&gt; m_chunkManagementPool;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    RelativePointer&lt;<span class="keyword">void</span>&gt; m_rawMemory;</span><br><span class="line">    freeList_t m_freeIndices;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么这些类定义里面，有两个重要的信息，一个是<code>MePooSegment::m_sharedMemoryObject</code>，这是一个非常重要的成员。我们已经知道<code>MePooSegment</code>代表一个内存段，他可能会很大，大到几个G。iceoryx中一个内存段对应一个<code>MePooSegment</code>对象，而一个<code>MePooSegment</code>对应一个<code>m_sharedMemoryObject</code>对象，因此实际上一个内存段会对应一个<code>m_sharedMemoryObjec</code>t对象，也就是会对应一个共享内存文件，通过这个共享内存的创建完成内存池的创建。</p>
<p>iceoryx没有把<code>m_sharedMemoryObject</code>整合到前面统一创建的整个内存段中，而是设计为一个独立的内存段，我个人理解是他要把管理和数据两类内存分开，前面统一创建的一片内存都是用于管理的目的，对应的共享内存文件名叫<code>iceoryx_mgmt</code>(后面master分支名字有变化)，可以看出是用于管理作用的。 而现在这里的内存是单纯作为内存池供用户存放业务数据的，作用上比较独立，所以就适合分开。</p>
<p><code>m_sharedMemoryObject</code>对应的共享内存文件名是你当前的用户名，比如你是root用户，那么对应的文件在linux系统中就是<code>/dev/shm/root</code>(后面master分支名字有变化)。那么如果多个<code>MePooSegment</code>对象对应的文件名又分别是什么呢？事实上当前的iceoryx并没有在事实上支持多个<code>MePooSegment</code>对象！</p>
<p><strong>虽然不论从数据结构层面和配置文件层面都是支持多个内存段的，但是实际使用上我发现并不支持，如果我配置了多个[[segment]]，那么创建的共享内存文件只包含最后一个内存段的空间大小，并且功能上也不再正常。</strong></p>
<p>上面类图中另一个重要信息是<code>MemoryManager</code>中有<code>m_memPoolVector</code>和<code>m_chunkManagementPool</code>，其中<code>m_memPoolVector</code>可以理解是对应了内存池。<code>m_chunkManagementPool</code>又是什么呢？</p>
<p>我们知道内存池都是固定大小的内存块，内存的块数也是确定的。每一块内存被申请使用时，需要通过引用计数确保内存被正确的释放，那么就需要有个memory wrapper这样的角色对内存地址进行封装，把内存地址和引用计数封装在一起。比如下面来自源码的类定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct ChunkManagement</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    iox::RelativePointer&lt;base_t&gt; m_chunkHeader;</span><br><span class="line">    referenceCounter_t m_referenceCounter&#123;1U&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一个内存块都需要一个memory wrapper进行管理，因此iceoryx最多需要N个memory wrapper进行管理，N是每一个pool的内存块个数的总和。上面类定义中<code>m_chunkManagementPool</code>就是指向一个分配<code>ChunkManagement</code>的内存池，这个内存池追加在上面无锁队列的后面，跟<code>m_memPoolVector</code>的内存池指向独立的共享内存文件不同，这点在后面的内存分配图中可以看出。</p>
<h3 id="完整的内存分配图"><a href="#完整的内存分配图" class="headerlink" title="完整的内存分配图"></a>完整的内存分配图</h3><p>下图是对上面内存分配的完整总结，大片的内存总共是两片，一个是文件名为<code>iceoryx_mgmt</code>的用于管理的内存，内存切分成多个不同的区域分给不同的对象管理；一个是文件名为用户名的用作内存池的内存，其大小受到配置文件的影响。</p>
<p><img src="/linkimage/iceoryx/iceoryx_memory_allocate.png" alt="iceoryx_memory_allocate"><br>(右键-在新标签页中打开图片，可以看得更清晰)</p>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><h3 id="初始化-initRuntime"><a href="#初始化-initRuntime" class="headerlink" title="初始化 initRuntime"></a>初始化 initRuntime</h3><h4 id="实例化-PoshRuntimeImpl"><a href="#实例化-PoshRuntimeImpl" class="headerlink" title="实例化 PoshRuntimeImpl"></a>实例化 PoshRuntimeImpl</h4><p>首先初始化Runtime的代码是：<code>iox::runtime::PoshRuntime::initRuntime(APP_NAME);</code>.<br>跟踪到内部后可以看到他就是实例化PoshRuntimeImpl并调用其构造函数， 但是他实例化的代码相对复杂，这里稍微展开一下。<br>实例化的核心代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PoshRuntime&amp; <span class="title">PoshRuntime::defaultRuntimeFactory</span><span class="params">(optional&lt;<span class="keyword">const</span> RuntimeName_t*&gt; name)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">typename</span> std::aligned_storage&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(PoshRuntimeImpl), <span class="built_in"><span class="keyword">alignof</span></span>(PoshRuntimeImpl)&gt;::type buf;</span><br><span class="line">    <span class="keyword">static</span> ScopeGuard staticLifetimeParticipant = [](<span class="keyword">auto</span> name) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">new</span></span> (&amp;buf) <span class="built_in">PoshRuntimeImpl</span>(name);</span><br><span class="line">        <span class="built_in">poshRuntimeNeedsManualDestruction</span>() = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getLifetimeParticipant</span>();</span><br><span class="line">    &#125;(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;PoshRuntimeImpl&amp;&gt;(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码里面创建了两个静态变量，一个是buf， 一个是staticLifetimeParticipant。其中buf就是一段内存对齐的buffer，他跟<code>char buf[sizeof(PoshRuntimeImpl)]</code>是差不多的。这个buf就是被创建来做为PoshRuntimeImpl的载体的，并在<code>new (&amp;buf) PoshRuntimeImpl(name);</code>中被执行实例化。staticLifetimeParticipant则是为了管理PoshRuntimeImpl的析构时机， staticLifetimeParticipant在被析构的时候会检查这是不是最后一个ScopeGuard（staticLifetimeParticipan的类型）， 如果是就析构PoshRuntimeImpl。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ScopeGuard <span class="title">PoshRuntime::getLifetimeParticipant</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ScopeGuard</span>([]() &#123; ++<span class="built_in">poshRuntimeStaticRefCount</span>(); &#125;,</span><br><span class="line">                      []() &#123;</span><br><span class="line">                          <span class="keyword">if</span> (<span class="number">0</span> == --<span class="built_in">poshRuntimeStaticRefCount</span>() &amp;&amp; <span class="built_in">poshRuntimeNeedsManualDestruction</span>())</span><br><span class="line">                          &#123;</span><br><span class="line">                              <span class="built_in">getInstance</span>().~<span class="built_in">PoshRuntime</span>();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说Runtime的实例PoshRuntimeImpl在第一次调用initRuntime的时候被实例化，实例化的对象存放在一段static的buf中；而PoshRuntimeImpl的析构则是在全部ScopeGuard被析构之后才被析构，所有在其生命周期中需要确保PoshRuntimeImpl存在的模块，都应该人为调用<code>static ScopeGuard staticLifetimeParticipant=getLifetimeParticipant()</code>在他的cpp中，以确保PoshRuntimeImpl能覆盖该模块的生命周期。<br>这种方式比较精确的控制了全局变量的构造和析构时机， 比简单的<code>static PoshRuntimeImpl impl;</code>要灵活和安全。这种方式有一个专门名字叫<code>nifty counter</code>. 可以参考<a target="_blank" rel="noopener" href="https://yukwan.cn/2024/02/07/3fcdefc8c29b/">c++ 全局变量初始化及惯用方法之 Nifty Counter</a>.</p>
<h4 id="PoshRuntimeImpl构造函数"><a href="#PoshRuntimeImpl构造函数" class="headerlink" title="PoshRuntimeImpl构造函数"></a>PoshRuntimeImpl构造函数</h4><p>PoshRuntimeImpl的构造函数中主要做两个事情，一个是<code>IpcRuntimeInterface::create</code>，一个是<code>SharedMemoryUser::create</code>.</p>
<p><code>IpcRuntimeInterface::create</code>中做的事情依次为：</p>
<ol>
<li>尝试建立与RouDi的Ipc连接， 在linux中， 其通过UnixDomainSocket来连接到RouDi的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32)</span></span><br><span class="line"><span class="keyword">using</span> IoxIpcChannelType = iox::NamedPipe;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__FREERTOS__)</span></span><br><span class="line"><span class="keyword">using</span> IoxIpcChannelType = iox::NamedPipe;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> IoxIpcChannelType = iox::UnixDomainSocket;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>尝试的意思是，连接，但是先容许错误， 因为RouDi可能此时还没有启动。</p>
<ol start="2">
<li><p>建立一个属于自己的DomianSocket，如果创建失败，会立即返回错误。成功后，会创建以runtimeName为文件名的DomianSocket, runtimeName就是initRuntime()函数中用户传入的参数。</p>
</li>
<li><p>如果1中连接连接失败， 就持续重试，直到超时返回错误，或者连接成功。</p>
</li>
<li><p>通过1中建立的连接，向RouDi发送一条REGISTER请求。请求中携带了runtimeName，因此， RouDi收到后，能够拼出此runtime的DomianSocket路径。</p>
</li>
<li><p>在2中创建的socket中等待RouDi对REGISTER的响应，直到超时返回，或者成功收到响应。收到响应后检查响应内容， 如果符合预期，拿到了相关的信息， 表示注册成功。 否则表示注册失败。成功之后完成<code>IpcRuntimeInterface::create</code>过程， 失败的话，就从第3步循环， 直到整个过程超时。</p>
</li>
</ol>
<p>所以如果<code>IpcRuntimeInterface::create</code>返回成功， 那就表示runtime已经成功与RouDi建立连接， 并且经过一轮交互，注册成功了。</p>
<p>注册成功后,接着就是执行<code>SharedMemoryUser::create</code>.</p>
<p><code>SharedMemoryUser::create</code>做的事本质上是把RouDi打开过的共享内存文件, 同样打开一遍. 前面我们梳理内存管理对象的时候有过这个关系: [总内存]-&gt;[内存段]-&gt;[内存池], 其中总内存和内存段是内存管理的对象, 他们位于叫<code>xxx_management</code>的以management为后缀的内存文件中, 而内存池, 则是实际用于分配的内存片段, 位于单独的<code>xxx_username</code>以你的实际用户名为后缀的内存文件中.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这是基于2025年初master分支编译的linux版本RouDi,运行后生成的两个对应的共享内存文件.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 较早的版本文件名中前缀并不一样, 但是后缀_management和_qiming是一样的.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /dev/shm -lh</span></span><br><span class="line">total 176M</span><br><span class="line">-rw-rw----  1 qiming qiming  34M  1月 28 18:05 iox1_0_i_management</span><br><span class="line">-rw-rw----+ 1 qiming qiming 143M  1月 28 18:05 iox1_0_u_qiming</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开的过程是这样的:</p>
<ol>
<li><p>打开_management为后缀的共享内存文件. 文件名是RouDi和Runtime用一致的规则拼接的,所以是一致的.</p>
</li>
<li><p>接着用打开的文件的基地址加上RouDi在response中响应回来的offset值,来定位到[总内存]这个管理对象的地址,并把地址强转成mepoo::SegmentManager*类型,来完成mepoo::SegmentManager对象的构造.</p>
</li>
<li><p>接着从SegmentManager中拿到[内存段]列表, 每个[内存段]对应一个共享内存文件, 于是打开对应的这个内存文件. 也就是以用户名为后缀的这个文件.通常[内存段]只用到一个, 所以上面我们ls出来只有一个用户名后缀的文件, 这一个内存文件包含了全部的内存池.</p>
</li>
<li><p>打开的这些内存文件,他的地址是怎么管理的呢, 他是把这个文件的地址跟一个segmentId进行关联,保存在全局的容器里面, 后续涉及获取这个内存地址的,都采用传入segmentId的方式进行获取.</p>
</li>
</ol>
<h3 id="借内存-loan"><a href="#借内存-loan" class="headerlink" title="借内存 loan"></a>借内存 loan</h3><p>loan内存经过的步骤:</p>
<ol>
<li><p>向RouDi申请创建Publisher, RouDi回复成功或者失败, 如果成功,就返回一个内存offset,对应了PublisherPortData对象的内存地址.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PublisherPortUserType::MemberType_t*</span></span><br><span class="line"><span class="function"><span class="title">PoshRuntimeImpl::getMiddlewarePublisher</span><span class="params">(<span class="keyword">const</span> capro::ServiceDescription&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">const</span> popo::PublisherOptions&amp; publisherOptions,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">const</span> PortConfigInfo&amp; portConfigInfo)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> maybePublisher = <span class="built_in">requestPublisherFromRoudi</span>(sendBuffer);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> maybePublisher.<span class="built_in">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">expected&lt;PublisherPortUserType::MemberType_t*, IpcMessageErrorType&gt;</span></span><br><span class="line"><span class="function"><span class="title">PoshRuntimeImpl::requestPublisherFromRoudi</span><span class="params">(<span class="keyword">const</span> IpcMessage&amp; sendBuffer)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    IpcMessage receiveBuffer;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sendRequestToRouDi</span>(sendBuffer, receiveBuffer) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (receiveBuffer.<span class="built_in">getNumberOfElements</span>() == <span class="number">3U</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stringToIpcMessageType</span>(IpcMessage.<span class="built_in">c_str</span>()) == IpcMessageType::CREATE_PUBLISHER_ACK)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// using MemberType_t = PublisherPortData;</span></span><br><span class="line">            <span class="comment">// RouDi返回的是PublisherPortData类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ok</span>(<span class="keyword">reinterpret_cast</span>&lt;PublisherPortUserType::MemberType_t*&gt;(ptr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于1中创建的PublisherPortData对象, 我们调用<code>PublisherPortData::m_chunkSenderData::m_memoryMgr::getChunk(xxx)</code>来获取一块满足大小的chunk也就是一块内存. 这里m_memoryMgr对象负责管理一个共享内存文件, 里面的对象被分成多个不同chunk size的pool, 也就是上面讲到过的内存管理方案([总内存]-&gt;[内存段]-&gt;[内存池])中内存段的管理对象,这个函数会遍历每一个不同chunk大小的pool, 遇到满足size的pool,就从pool中申请一块, 这个pool中没有空闲了,就返回不错, 不向更大的pool申请.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">expected&lt;SharedChunk, MemoryManager::Error&gt; <span class="title">MemoryManager::getChunk</span><span class="params">(<span class="keyword">const</span> ChunkSettings&amp; chunkSettings)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; memPool : m_memPoolVector)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> chunkSizeOfMemPool = memPool.<span class="built_in">getChunkSize</span>();</span><br><span class="line">        <span class="keyword">if</span> (chunkSizeOfMemPool &gt;= requiredChunkSize)</span><br><span class="line">        &#123;</span><br><span class="line">            chunk = memPool.<span class="built_in">getChunk</span>();</span><br><span class="line">            memPoolPointer = &amp;memPool;</span><br><span class="line">            aquiredChunkSize = chunkSizeOfMemPool;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以看出第一步只要做一次, 第二步则是loan一次执行一次. 第一步在publisher的构造函数中的得到执行, 第二步在每次调用loan函数时候得到执行.</p>
<h3 id="发数据-publish"><a href="#发数据-publish" class="headerlink" title="发数据 publish"></a>发数据 publish</h3><p>发数据的过程, 核心还是在上面创造的<code>PublisherPortData</code>对象, 在<code>PublisherPortData::m_chunkSenderData::m_queues</code>中保存了数据发送的目标队列,也就是<code>subscriber</code>队列.我们遍历这个队列,然后把我们要发送的chunk塞进队列中, 如果存在对应的<code>condition_variable</code>, 就同时触发一次唤醒.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChunkDistributorDataType&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">uint64_t</span> ChunkDistributor&lt;ChunkDistributorDataType&gt;::<span class="built_in">deliverToAllStoredQueues</span>(mepoo::SharedChunk chunk) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">            <span class="comment">// send to all the queues</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; queue : <span class="built_in">getMembers</span>()-&gt;m_queues)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pushToQueue</span>(queue.<span class="built_in">get</span>(), chunk))</span><br><span class="line">            &#123;</span><br><span class="line">                ++numberOfQueuesTheChunkWasDeliveredTo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              ...   </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChunkDistributorDataType&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> ChunkDistributor&lt;ChunkDistributorDataType&gt;::<span class="built_in">pushToQueue</span>(not_null&lt;ChunkQueueData_t* <span class="keyword">const</span>&gt; queue,</span><br><span class="line">                                                                    mepoo::SharedChunk chunk) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ChunkQueuePusher_t</span>(queue).<span class="built_in">push</span>(chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ChunkQueueDataType&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> ChunkQueuePusher&lt;ChunkQueueDataType&gt;::<span class="built_in">push</span>(mepoo::SharedChunk chunk) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> pushRet = <span class="built_in">getMembers</span>()-&gt;m_queue.<span class="built_in">push</span>(chunk);</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> MemberType_t::LockGuard_t <span class="title">lock</span><span class="params">(*getMembers())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getMembers</span>()-&gt;m_conditionVariableDataPtr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ConditionNotifier</span>(*<span class="built_in">getMembers</span>()-&gt;m_conditionVariableDataPtr.<span class="built_in">get</span>(),</span><br><span class="line">                              *<span class="built_in">getMembers</span>()-&gt;m_conditionVariableNotificationIndex)</span><br><span class="line">                .<span class="built_in">notify</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于理解逻辑, 代码只要看其中的大意, 他代码用了大量的模板, 要全部理清楚,要费很多时间.</p>
<p><code>publish</code>这部分逻辑上面<code>CREATE_CONDITION_VARIABLE 命令</code>小节中已经梳理过一遍, 包括<code>subscriber</code>的逻辑也已经被包含在一起了. 如果感兴趣可以往回回看那小节.</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>iceoryx目前比较成熟, 零拷贝的设计也很好, 但是他存在中心节点这一点比较有争议, 也一定程度上影响他的应用.</p>
<p>iceoryx目前社区已经在开发iceoryx2, 他重构了设计, 移除了中心节点这一设计. 值得关注.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/payimage/wechat.png" alt="yizhiren 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/payimage/zhifubao.png" alt="yizhiren 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%80%9A%E4%BF%A1/" rel="tag"># 通信</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/11/sync/" rel="prev" title="同步三要素">
                  <i class="fa fa-angle-left"></i> 同步三要素
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备14030596号-5 </a>
      <img src="https://beian.mps.gov.cn/web/assets/logo01.6189a29f.png" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=33011002016624" rel="noopener" target="_blank">浙公网安备 33011002016624号 </a>
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">yizhiren</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"yizhiren","repo":"yizhiren.github.io","client_id":"f06437e321af81a44e6e","client_secret":"fc63095ff123d820c599d51aaf2030b542bf8854","admin_user":"yizhiren","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"05a37aaeae61567a93be66ccdff78f63"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
